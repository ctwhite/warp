;;; warp-service.el --- Unified Service Definition, Registry, and RPC Generation -*- lexical-binding: t; -*-

;;; Commentary:
;;
;; This module is the foundation for a Service-Oriented Architecture (SOA)
;; within the Warp framework. It provides the core machinery for defining,
;; implementing, discovering, and consuming services, effectively acting as
;; the central nervous system for distributed communication.
;;
;; ## Architectural Goal: A "Service Mesh in a Box"
;;
;; This module provides the tools to build a "service mesh in a box"
;; directly within the Warp framework, turning a collection of workers
;; into a cohesive, resilient, and observable system. It achieves this
;; by providing both a "control plane" (the service registry) and a
;; "data plane" (the smart client middleware).
;;
;; ### How This File Implements Service Mesh Concepts
;;
;; - **API Contract (The Source of Truth)**:
;;   The `warp:defservice-interface` macro defines a language-agnostic
;;   contract for a service, ensuring all parties agree on the API.
;;
;; - **Code Generation (Automating the Boilerplate)**:
;;   The `warp:defservice-implementation` macro is the engine that brings
;;   the contract to life. At compile time, it reads the contract and
;;   auto-generates the entire RPC stack, including data schemas, a
;;   smart client, and server-side routing logic.
;;
;; - **Policy Registry**:
;;   `warp:defpolicy` and `warp:defpolicy-set` allow operators to define
;;   named, reusable resilience policies (e.g., for retries, timeouts)
;;   that can be declaratively applied to service clients.
;;
;; - **Smart Client & Middleware (The Data Plane)**:
;;   The `warp-service-client` and its middleware pipeline act as the
;;   data plane. When a client method is called, it executes a series of
;;   steps: discovery, load balancing, resilience, and connection
;;   management, offloading all complex network logic from the developer.
;;
;; ## Enhancement: Pluggable Discovery Resolvers
;;
;; This version of the module is refactored to support multiple, pluggable
;; service discovery sources. Instead of having hard-coded logic for the
;; internal registry and service mesh, it now uses a central registry for
;; "resolvers." This allows components like `warp-dns-plugin.el` to
;; register themselves as a valid discovery source, enabling a multi-source,
;; consensus-based discovery model. This significantly enhances the
;; resilience and consistency of the entire discovery process.

;;; Code:

(require 'cl-lib)
(require 's)
(require 'loom)
(require 'braid)
(require 'json)

(require 'warp-log)
(require 'warp-error)
(require 'warp-event)
(require 'warp-balancer)
(require 'warp-registry)
(require 'warp-rpc)
(require 'warp-component)
(require 'warp-plugin)
(require 'warp-protocol)
(require 'warp-middleware)
(require 'warp-circuit-breaker)
(require 'warp-httpd)
(require 'dns)

;; Forward declarations for core types.
(cl-deftype warp-service-registry () t)
(cl-deftype warp-service-endpoint () t)
(cl-deftype warp-service-info () t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Error Definitions

(define-error 'warp-service-error
  "Base error for all service-related operations."
  'warp-error)

(define-error 'warp-service-not-found
  "The requested service could not be found or no healthy endpoints
were available."
  'warp-service-error)

(define-error 'warp-service-contract-violation
  "A service implementation does not fulfill its interface contract."
  'warp-error)

(define-error 'warp-service-rpc-config-error
  "An invalid configuration was provided for RPC generation."
  'warp-service-error)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Global State

(defvar warp--service-interface-registry (make-hash-table :test 'eq)
  "Global registry for all service interface contracts, populated by
`warp:defservice-interface`.")

(defvar warp--service-implementations-registry (make-hash-table :test 'eq)
  "Global registry mapping interface names to their
implementations.")

(defvar warp--service-initializers '()
  "A list of service initializer functions, generated by
`warp:defservice-implementation` and run at startup.")

(defvar warp--policy-registry (make-hash-table :test 'eq)
  "A global registry for all named, reusable service policies,
populated by the `warp:defpolicy` macro.")

(defvar warp--service-resolver-registry
  (warp:registry-create :name "service-resolver-registry")
  "A central registry for all pluggable service discovery resolvers.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Configuration

(warp:defconfig service-config
  "Defines service-wide configuration settings for the Warp framework,
particularly for service mesh integration.

Fields:
- `service-mesh-enabled-p`: If non-nil, service discovery is delegated
  to a local service mesh sidecar. This bypasses the internal registry.
- `service-mesh-proxy-address`: The HTTP address of the local service
  mesh sidecar proxy's discovery API."
  (service-mesh-enabled-p nil :type boolean
                          :doc "If non-nil, service discovery is delegated
to a local service mesh sidecar, bypassing the internal registry.")
  (service-mesh-proxy-address "http://localhost:15020" :type string
                              :doc "The HTTP address of the local service
mesh sidecar proxy's discovery API."))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Policy Schemas and Generic Dispatch

(cl-defstruct (warp-retry-policy
               (:constructor make-warp-retry-policy))
  "A policy for handling failed requests via retries.

Fields:
- `retries`: The number of times to retry a failed request.
- `delay-strategy`: The strategy for delays between retries.
- `delay-options`: Options for the delay strategy."
  (retries (cl-assert nil) :type integer)
  (delay-strategy (cl-assert nil) :type keyword)
  (delay-options (cl-assert nil) :type plist))

(cl-defstruct (warp-timeout-policy
               (:constructor make-warp-timeout-policy))
  "A policy for enforcing a timeout on a request.

Fields:
- `timeout`: The timeout duration in seconds."
  (timeout (cl-assert nil) :type float))

(cl-defstruct (warp-load-balancer-policy
               (:constructor make-warp-load-balancer-policy))
  "A policy for selecting a service endpoint.

Fields:
- `type`: The load balancing algorithm to use.
- `options`: Options for the algorithm."
  (type (cl-assert nil) :type keyword)
  (options (cl-assert nil) :type plist))

(cl-defgeneric warp:apply-retry-policy (policy callable)
  "Applies the retry policy to a callable function.
This is the core of the retry policy strategy.

Arguments:
- `policy` (warp-retry-policy): The policy to apply.
- `callable` (function): The function to execute and potentially retry.

Returns:
- (loom-promise): A promise that resolves with the result of the
  callable."
  (:method ((policy warp-retry-policy) callable)
    (let ((retries (warp-retry-policy-retries policy)))
      (loom:retry (funcall callable) :retries retries))))

(cl-defgeneric warp:apply-load-balancer-policy (policy endpoints)
  "Applies the load balancing policy to a list of endpoints.

Arguments:
- `policy` (warp-load-balancer-policy): The load balancing policy.
- `endpoints` (list): The list of available service endpoints.

Returns:
- (t): The selected endpoint from the list."
  (:method ((policy warp-load-balancer-policy) endpoints)
    (let ((load-balancer-type (warp-load-balancer-policy-type policy)))
      (warp:balance endpoints
                    (warp:balancer-strategy-create :type load-balancer-type)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Public API for Policies

(defmacro warp:defpolicy (name type docstring &rest options)
  "Defines and registers a named, reusable service policy.
This macro registers a policy blueprint in a global registry.

Arguments:
- `name` (keyword): The unique name for this policy (e.g., `:aggressive-retry`).
- `type` (keyword): The type of policy (e.g., `:retry`, `:timeout`).
- `docstring` (string): Documentation for the policy.
- `options` (plist): A property list of policy-specific options.

Returns:
- `name` (symbol)."
  (let ((policy-constructor (intern (format "make-warp-%s-policy" type))))
    `(progn
       (puthash ',name (list :type ',type :constructor ',policy-constructor
                             :options ',options)
                warp--policy-registry)
       ',name)))

;;;###autoload
(defmacro warp:defpolicy-set (name docstring &rest policy-names)
  "Defines a reusable collection of named policies.
This macro bundles a list of policy names into a single, named unit.

Arguments:
- `name` (keyword): The name for the policy set.
- `docstring` (string): Documentation for the policy set.
- `policy-names` (list): A list of policy names to include in the set."
  `(defconst ,name ',policy-names ,docstring))
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Private Middleware & Pipeline Logic

(defun warp-service--rpc-call-middleware-function (context next-function)
  "Private: Middleware to execute the RPC call on the server side.

Arguments:
- `context` (plist): The context containing `:command` and `:impl-instance`.
- `next-function` (function): The next function in the pipeline.

Returns:
- (loom-promise): A promise that resolves with the updated context."
  (let ((command (plist-get context :command))
        (implementation (plist-get context :impl-instance)))
    (braid! (apply (warp-command-executor command)
                   (list implementation command context))
      (:then (result)
             (funcall next-function (plist-put context :result result))))))

(defun warp-service--dial-endpoint-middleware (context next-function)
  "Private: Middleware to discover, balance, and connect to a service.
This delegates the entire connection process to the `warp-dialer`.

Arguments:
- `context` (plist): The context containing `:service-client` and `:service-name`.
- `next-function` (function): The next function in the pipeline.

Returns:
- (loom-promise): A promise that resolves after `next-function` completes."
  (let* ((client (plist-get context :service-client))
         (service-name (plist-get context :service-name))
         (dialer (warp-service-client-dialer client)))
    (braid! (warp:dialer-dial dialer service-name)
      (:then (connection)
             (funcall next-function (plist-put context
                                               :connection connection))))))

(defun warp-service--apply-resilience-middleware (context next-function)
  "Private: Middleware to wrap the downstream call in resilience policies.

Arguments:
- `context` (plist): Context with `:service-client` and `:service-name`.
- `next-function` (function): The rest of the pipeline to call.

Returns:
- (loom-promise): Promise for the resiliently executed pipeline result."
  (let* ((client (plist-get context :service-client))
         (service-name (plist-get context :service-name))
         (policies (gethash service-name
                            (warp-service-client-policies client)))
         (retry-policy (gethash :retry-policy policies))
         (timeout-policy (gethash :timeout-policy policies))
         (cb-config (plist-get policies :circuit-breaker))
         (callable (lambda () (funcall next-function context)))
         final-callable)
    ;; Wrap the core `callable` with resilience patterns, inside-out.
    (setq final-callable callable)
    (when timeout-policy
      (setq final-callable
            (lambda () (loom:with-timeout
                           (warp-timeout-policy-timeout timeout-policy)
                         (funcall final-callable)))))
    (when cb-config
      (let ((breaker (apply #'warp:circuit-breaker-get-or-create
                            (symbol-name service-name) cb-config)))
        (setq final-callable
              (lambda () (warp:circuit-breaker-execute
                             breaker final-callable)))))
    (when retry-policy
      (setq final-callable (lambda () (warp:apply-retry-policy
                                        retry-policy final-callable))))
    (funcall final-callable)))

(defun warp-service--rpc-client-send-middleware (context next-function)
  "Private: Middleware to send the RPC command over the wire.

Arguments:
- `context` (plist): The full context for the RPC call.
- `next-function` (function): The next function in the pipeline.

Returns:
- (loom-promise): A promise that resolves with the updated context."
  (let* ((client (plist-get context :service-client))
         (rpc (warp-service-client-rpc-system client))
         (connection (plist-get context :connection))
         (endpoint (plist-get context :selected-endpoint))
         (command (plist-get context :command))
         (options (plist-get context :options)))
    (braid! (warp:rpc-send
             rpc connection
             :recipient-id (warp-service-endpoint-worker-id endpoint)
             :command command
             :stream (plist-get options :stream)
             :expect-response (not (plist-get options :fire-and-forget)))
      (:then (result) (funcall next-function
                                (plist-put context :result result)))
      (:catch (error)
              (error (plist-get options :service-error-type)
                     (format "RPC to '%s' failed"
                             (plist-get options :method-name))
                     error)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Private Functions

;;;---------------------------------------------------------------------------
;;; RPC Generation Helpers (Internal)
;;;---------------------------------------------------------------------------

(defun warp-service--generate-client-struct (client-class protocol-name)
  "Private: Generate the `cl-defstruct` form for a protocol's client.
This function creates the client-side state object. This object holds
a reference to the underlying `warp-service-client` that handles all
network-level concerns (discovery, load balancing, resilience),
decoupling the high-level API from the low-level transport details.

Arguments:
- `client-class` (symbol): The symbol name for the client struct.
- `protocol-name` (symbol): The name of the service protocol.

Returns:
- (list): A complete `(cl-defstruct ...)` S-expression."
  `(cl-defstruct (,client-class
                  (:constructor ,(intern (format "make-%s" client-class))))
     ,(format "Client for the %s protocol." protocol-name)
     (service-client (cl-assert nil) :type (or null t))))

(defun warp-service--generate-auto-schema-form (protocol method args)
  "Private: Generate a `warp:defschema` form for an RPC method's arguments.
This function creates a data schema for the RPC method's arguments. This
schema is used for type-safe serialization and deserialization,
ensuring a consistent contract for data exchange between services. It
automatically filters out Lisp lambda-list keywords from the
argument list.

Arguments:
- `protocol` (symbol): The protocol namespace.
- `method` (symbol): The specific method name.
- `args` (list): The raw argument list from the method's definition.

Returns:
- (list): A complete `(warp:defschema ...)` S-expression."
  (let* ((schema-name (intern (format "warp-%s-%s-request" protocol method)))
         (fields (cl-loop for arg in args
                          unless (memq arg '(&key &optional &rest))
                          collect `(,arg nil :serializable-p t))))
    `(warp:defschema ,schema-name (:generate-protobuf t) ,@fields)))

(defun warp-service--generate-client-method (client-class protocol rpc-def specs
                                                          global-opts client-middleware)
  "Private: Generate a client-side stub function for an RPC method.
This function is the core of the client-side code generation. It
produces a Lisp function that hides all RPC complexity from the user.
The generated function wraps the RPC call in a middleware pipeline
that handles:
1. Packaging arguments into a command object.
2. Building the full execution context.
3. Running the middleware stages (resilience, discovery, transport).

Arguments:
- `client-class` (symbol): The name of the client struct.
- `protocol` (symbol): The name of the protocol namespace.
- `rpc-def` (list): The base definition of the RPC method.
- `specs` (list): The full list of method specs from the interface.
- `global-opts` (plist): RPC options that apply to all methods.
- `client-middleware` (list): User-provided middleware stages.

Returns:
- (list): A complete `(cl-defun ...)` S-expression."
  (let* ((method (car rpc-def)) (arguments (cadr rpc-def))
         (spec (cl-find method specs :key #'car))
         (options (append (plist-get (cdddr spec) :rpc-options) global-opts))
         (schema (plist-get options :request-schema))
         (fn-name (intern (format "%s-%s" client-class method)))
         (command (intern (format ":%s/%s" protocol method)))
         (service-name (intern (symbol-name protocol) :keyword))
         (err-type (intern (format "%s-RPC-ERROR" protocol)))
         (payload (cl-loop for arg in arguments
                           unless (memq arg '(&key &optional &rest))
                           collect `(,(intern (symbol-name arg) :keyword)
                                     ,arg)))
         (opts-plist `(:method-name ',method
                       :service-error-type ',err-type
                       :stream ,(plist-get options :stream)
                       :fire-and-forget ,(plist-get options :fire-and-forget)))
         (pipeline-name (intern (format "client-pipeline-%s/%s"
                                        protocol method))))
    `(cl-defun ,fn-name (client ,@arguments)
       ,(format "Sends a %S RPC with discovery and resilience." command)
       (let* ((svc-client (,(intern (format "%s-service-client" client-class))
                           client))
              ;; Package args into a structured RPC command object.
              (cmd-obj (make-warp-rpc-command
                        :name ',command
                        :arguments (,(intern (format "make-%s" schema))
                                    ,@payload)))
              ;; Prepare the initial context for the pipeline.
              (context `(:service-client ,svc-client
                         :service-name ,service-name
                         :command ,cmd-obj
                         :options ,opts-plist))
              ;; Define the full execution pipeline with all stages.
              (pipeline (warp:middleware-pipeline-create
                         :name ',pipeline-name
                         :stages
                         (append
                          ,client-middleware
                          (list (warp:defmiddleware-stage
                                 :apply-resilience
                                 #'warp-service--apply-resilience-middleware)
                                (warp:defmiddleware-stage
                                 :dial-endpoint
                                 #'warp-service--dial-endpoint-middleware)
                                (warp:defmiddleware-stage
                                 :send-rpc-command
                                 #'warp-service--rpc-client-send-middleware))))))
         (braid! (warp:middleware-pipeline-run pipeline context)
           ;; Extract the final result from the pipeline's context.
           (:then (final-ctx) (plist-get final-ctx :result)))))))

(defun warp-service--generate-command-definition (protocol rpc-def)
  "Private: Generate a `warp:defcommand` for a single RPC method.
This function creates the server-side command definition, which
links an incoming RPC command to a concrete handler function.

Arguments:
- `protocol` (symbol): The protocol namespace for the command.
- `rpc-def` (list): The full definition of a single RPC method.

Returns:
- (list): A complete `(warp:defcommand ...)` S-expression."
  (let* ((method (car rpc-def))
         (handler (plist-get (cdddr rpc-def) :handler))
         (command (intern (format ":%s/%s" protocol method)))
         (doc (cadr handler)) (args (caddr handler)) (body (cdddr handler)))
    `(warp:defcommand ,command ,doc :arguments ',args :execute (lambda ,args ,@body))))

(defun warp-service--generate-handler-registration
    (router protocol rpc-def impl-key server-middleware)
  "Private: Generate the Lisp form to add a command handler to a router.
This function creates the logic for the RPC router to dispatch an
incoming command to the correct server-side middleware pipeline. It
dynamically injects the service implementation via the component
system.

Arguments:
- `router` (symbol): The variable name holding the router instance.
- `protocol` (symbol): The protocol namespace.
- `rpc-def` (list): The definition of a single RPC method.
- `impl-key` (keyword): The DI key for the service component.
- `server-middleware` (list): User-provided server-side middleware.

Returns:
- (list): A complete `(warp:command-router-add-route ...)` S-expression."
  (let* ((method (car rpc-def))
         (command (intern (format ":%s/%s" protocol method)))
         (pipeline-name (intern (format "pipeline-%s" command))))
    `(warp:command-router-add-route ,router ',command
       :handler-function
       (lambda (cmd-obj context)
         (let* ((system (plist-get context :host-system))
                ;; Resolve the concrete service implementation via DI.
                (impl (warp:component-system-get system ,impl-key))
                (plugin-system (warp:component-system-get system :plugin-system))
                (contribs (when plugin-system
                            (warp:get-plugin-contributions
                             plugin-system :service-rpc-middleware)))
                ;; Assemble the final server-side pipeline.
                (pipeline
                 (warp:middleware-pipeline-create
                  :name ',pipeline-name
                  :stages (append ,server-middleware (car contribs)
                                  (list (warp:defmiddleware-stage
                                         :rpc-call
                                         #'warp-service--rpc-call-middleware-function))))))
           (warp:middleware-pipeline-run pipeline `(:command ,cmd-obj
                                                    :context ,context
                                                    :impl-instance ,impl)))))))

(defun warp-service--generate-protocol-forms (protocol iface-name impl-name rpc-opts)
  "Private: Orchestrate the entire code generation for a service's RPC.
This function is the master entry point for the code-generation macro.
It iterates over all methods in the service interface and generates
the necessary structs, schemas, and functions for both the client and
the server.

Arguments:
- `protocol` (symbol): The unique name for the generated protocol.
- `iface-name` (symbol): The service interface being implemented.
- `impl-name` (symbol): The name of the component with the implementation.
- `rpc-opts` (plist): Configuration options for the RPC layer.

Returns:
- (list): A `(progn ...)` S-expression containing all generated code.

Signals:
- `warp-service-contract-violation`: If `iface-name` is not known."
  (let* ((client-class (plist-get rpc-opts :client-class))
         (auto-schema (plist-get rpc-opts :auto-schema))
         (server-middleware (plist-get rpc-opts :server-middleware))
         (client-middleware (plist-get rpc-opts :client-middleware))
         (impl-key (intern (format ":%s" impl-name)))
         (iface-def (gethash iface-name warp--service-interface-registry))
         (methods (plist-get iface-def :methods))
         (reg-fn (intern (format "%%register-%s-handlers" protocol)))
         (err-type (when client-class
                     (intern (format "%s-RPC-ERROR" protocol)))))

    ;; Pre-condition check: Ensure the macro is implementing a valid interface
    ;; that has been registered. This is a critical meta-programming sanity check.
    (unless iface-def
      (error 'warp-service-contract-violation
             (format "Service interface '%s' not found" iface-name)))

    (let ((schema-forms) (client-forms) (cmd-defs) (handler-regs))
      (dolist (spec methods)
        (cl-destructuring-bind (method args &key doc rpc-options) spec
          (let* ((impl-fn (intern (format "%s-%s" impl-name method)))
                 (handler-args (remove-if #'keywordp args))
                 (schema (when auto-schema
                           (intern (format "warp-%s-%s-request"
                                           protocol method))))
                 ;; Define a structured representation of the RPC for
                 ;; internal use by the generation functions.
                 (rpc-def `(,method ,args
                            ,@(when auto-schema `(:request-schema ,schema))
                            :handler
                            (lambda (,impl-name cmd-obj _ctx)
                              ,(or doc "Proxy handler")
                              ;; The handler uses `apply` to dynamically call the
                              ;; user's function with arguments extracted from the
                              ;; incoming command object.
                              (apply #',impl-fn ,impl-name
                                     (mapcar (lambda (a)
                                               `(plist-get
                                                 (warp-rpc-command-arguments
                                                  cmd-obj)
                                                 ',(intern (symbol-name a)
                                                           :keyword)))
                                             handler-args))))))

            ;; Generate the schema for the RPC arguments.
            (when auto-schema
              (push (warp-service--generate-auto-schema-form
                     protocol method args) schema-forms))
            
            ;; Generate the client-side stub function that users will call.
            (when client-class
              (push (warp-service--generate-client-method
                     client-class protocol rpc-def specs rpc-opts
                     client-middleware) client-forms))
            
            ;; Generate the server-side command definition.
            (push (warp-service--generate-command-definition
                   protocol rpc-def) cmd-defs)
            
            ;; Generate the registration call to wire the handler to the router.
            (push (warp-service--generate-handler-registration
                   'router protocol rpc-def impl-key server-middleware)
                  handler-regs))))
      
      ;; The final return form is a `progn` that assembles all
      ;; the generated code into a single block to be executed.
      `(progn
         ,@(when err-type
             `((define-error ',err-type "RPC error" 'warp-service-error)))
         ,@(nreverse schema-forms)
         ,@(when client-class
             `(,(warp-service--generate-client-struct client-class protocol)))
         ,@(nreverse client-forms)
         ,@(nreverse cmd-defs)
         ;; The registration function is a separate utility to allow
         ;; deferred or dynamic registration of handlers at runtime.
         (defun ,reg-fn (router)
           ,(format "Register all handlers for the %s protocol." protocol)
           ,@(nreverse handler-regs))))))

;;;---------------------------------------------------------------------------
;;; Service Registry & Client Functions
;;;---------------------------------------------------------------------------

(defun warp:service-registry-create (&key id event-system rpc-system
                                          load-balancer endpoint-pool)
  "Public: Create and initialize a new `warp-service-registry` component.
This is the central factory for the service registry. It sets up the
endpoint registry with proper indexing and wires it to the cluster's
event system to react to worker lifecycle changes. It also exposes
itself via RPC so other nodes can query it for service endpoints.

Arguments:
- `:id` (string): A unique identifier for this registry instance.
- `:event-system` (warp-event-system): The cluster's central event bus.
- `:rpc-system` (warp-rpc-system): The master's RPC system.
- `:load-balancer` (warp-balancer-strategy): The cluster's load balancer.
- `:endpoint-pool` (warp-resource-pool): The pool for endpoint objects.

Returns:
- (warp-service-registry): A new, initialized registry instance."
  (let* ((reg-name (format "service-catalog-%s" id))
         (endpoint-reg (warp:registry-create
                        :name reg-name :event-system event-system
                        :indices `((:service-name
                                    . ,#'warp-service-endpoint-service-name)
                                   (:worker-id
                                    . ,#'warp-service-endpoint-worker-id))))
         (registry (%%make-service-registry
                    :id (format "service-registry-%s" id)
                    :endpoint-registry endpoint-reg
                    :event-system event-system
                    :load-balancer load-balancer
                    :endpoint-pool endpoint-pool)))
    (dolist (event-type '(:worker-registered
                          :worker-deregistered
                          :worker-health-status-changed))
      (warp:subscribe event-system event-type
                      (lambda (event)
                        (warp-service-registry--on-worker-event
                         registry event-type event))))
    (when rpc-system
      (let ((router (warp:rpc-system-command-router rpc-system)))
        (warp:defrpc-handlers router
          (:service-select-endpoint
           (lambda (cmd _)
             (let ((args (warp-rpc-command-args cmd)))
               (warp:service-registry-select-endpoint
                registry (plist-get args :service-name)))))
          (:service-list-all
           (lambda (_c _x) (warp:service-registry-list-all registry))))))
    
    ;; Register the default internal resolver.
    (warp:register-service-resolver :internal
                                    (lambda (service-name)
                                      (warp-service--internal-resolve registry service-name)))

    ;; Register the service mesh resolver.
    (when (warp:service-mesh-enabled-p)
      (warp:register-service-resolver :service-mesh
                                      #'warp:service-mesh-resolve))
    
    registry))


(cl-defun warp:service-registry-list-endpoints (registry service-name)
  "Public: Orchestrates multi-source service discovery for an endpoint.

This function serves as the core of the enhanced discovery system. It looks
up all available resolvers in the central resolver registry, runs them
in parallel, and applies a consensus algorithm to the results to
determine a final, authoritative list of endpoints.

Arguments:
- `registry` (warp-service-registry): The internal service registry.
- `service-name` (keyword): The logical name of the service to find.

Returns:
- (loom-promise): A promise that resolves with a list of `warp-service-endpoint`
  objects that passed the consensus check, or rejects if no consensus is
  reached or if a severe error occurs during resolution."
  (let ((resolvers (hash-table-values warp--service-resolver-registry)))
    (braid! (loom:all-settled (cl-loop for resolver in resolvers
                                       collect (funcall resolver service-name)))
      (:then (results)
        (let ((valid-endpoints
               (cl-loop for res in results
                        when (eq (plist-get res :status) 'fulfilled)
                        collect (plist-get res :value))))
          (if valid-endpoints
              (warp-service--consensus-select valid-endpoints)
            (loom:rejected!
             (warp:error! :type 'warp-service-not-found
                          :message "No service discovery sources were successful."))))))))

(cl-defun warp:service-client-create (&key rpc-system dialer policy-set-name)
  "Public: Create a new client-side service component with a named policy set.
This factory assembles a 'smart client' that bundles the RPC system,
dialer, and resilience policies. The policies are loaded from a
pre-defined policy set to enforce consistent behavior.

Arguments:
- `:rpc-system` (warp-rpc-system): The RPC system for sending requests.
- `:dialer` (warp-dialer-service): The dialer for connecting to endpoints.
- `:policy-set-name` (keyword): The name of a `warp:defpolicy` set.

Returns:
- (warp-service-client): A new client instance configured with policies.

Signals:
- `error`: If `policy-set-name` is not found."
  (let* ((policy-set (gethash policy-set-name warp--policy-registry))
         (policies (make-hash-table :test 'eq)))
    ;; Ensure the requested policy set exists.
    (unless policy-set
      (error "Policy set '%s' not found in registry." policy-set-name))
    ;; Iterate over the policy set and create policy objects.
    (dolist (policy-spec policy-set)
      (let* ((policy-name (car policy-spec))
             (policy-type (getf policy-spec :type))
             (policy-opts (getf policy-spec :options)))
        (puthash policy-name (apply (getf policy-spec :constructor)
                                    policy-opts) policies)))
    ;; Return the fully assembled client instance.
    (%%make-service-client
     :rpc-system rpc-system
     :dialer dialer
     :policies policies)))

;;;---------------------------------------------------------------------------
;;; Pluggable Resolvers and Consensus
;;;---------------------------------------------------------------------------

(defun warp-service--internal-resolve (registry service-name)
  "Private: The internal resolver function.
This function wraps the standard registry lookup.

Arguments:
- `registry` (warp-service-registry): The internal registry instance.
- `service-name` (keyword): The logical name of the service.

Returns:
- (loom-promise): A promise that resolves to a list of endpoints."
  (warp:service-registry-select-endpoints registry service-name))


(defun warp-service--send-http-request (conn method path &key headers body)
  "Private: Sends a simple HTTP request over a raw transport connection.
This function manually constructs and sends an HTTP/1.1 request string
over a `warp-transport` connection. It then waits for and returns the
raw response body.

Arguments:
- `conn` (warp-transport-connection): The raw transport connection to use.
- `method` (string): The HTTP method (e.g., \"GET\").
- `path` (string): The request path (e.g., \"/api/v1/status\").
- `:headers` (hash-table, optional): A hash table of custom headers.
- `:body` (string or vector, optional): The request body.

Returns:
- (loom-promise): A promise that resolves with the response body as a string.

Signals:
- Rejects if the request fails or if the response is malformed."
  (let* ((http-request-string
          (with-temp-buffer
            (insert (format "%s %s HTTP/1.1\r\n" method path))
            (maphash (lambda (k v) (insert (format "%s: %s\r\n"
                                                   (s-capitalize k) v)))
                     headers)
            (insert "\r\n")
            (buffer-string)))
         (body-bytes (if body (string-to-utf8 body) "")))
    (braid! (warp:transport-send conn (string-to-utf8 http-request-string))
      (:then (_send-result)
        (warp:transport-send conn body-bytes))
      (:then (_send-result)
        (warp:transport-receive conn 5.0)) ;; Use a 5s timeout
      (:then (raw-response-bytes)
        (let* ((response-string (string-decode-utf8 raw-response-bytes))
               (sep (s-index-of "\r\n\r\n" response-string))
               (body-string (if sep (substring response-string (+ sep 4)))))
          (if body-string
              (loom:resolved! body-string)
            (loom:rejected!
             (warp:error! :type 'warp-service-error
                          :message "Empty response from mesh proxy."))))))))

(defun warp:service-mesh-resolve (service-name)
  "Public: Resolve a service address through a local service mesh proxy.
This function is the primary interface for a service mesh-aware dialer.
It communicates with the local sidecar to get a valid address for the
requested service, using the core `warp-transport` layer.

Arguments:
- `SERVICE-NAME` (keyword): The logical name of the service.

Returns:
- (loom-promise): A promise that resolves with a `warp-service-endpoint`
  struct containing the resolved address.

Signals:
- Rejects if the mesh proxy is unavailable or cannot resolve the service."
  (let* ((mesh-config (warp:get-config :service-config))
         (proxy-addr (plist-get mesh-config :service-mesh-proxy-address))
         (service-host (s-replace "-" "." (symbol-name service-name)))
         (transport-addr (warp-httpd--normalize-address proxy-addr 15020)))

    (warp:log! :debug "warp-service"
               "Resolving service '%s' via mesh at %s."
               service-name transport-addr)

    (braid! (warp:transport-connect transport-addr)
      (:then (connection)
        (unwind-protect
            (warp-service--send-http-request
             connection "GET" (format "/%s" service-host))
          (loom:await (warp:transport-close connection))))
      (:then (response-body-string)
        ;; Assume the response body is JSON containing the resolved address.
        (let ((resolved-addr (json-read-from-string response-body-string)))
          (warp:log! :info "warp-service" "Mesh resolved '%s' to '%s'."
                     service-name resolved-addr)
          (make-warp-service-endpoint
           :name service-name
           :address resolved-addr
           :protocol :tcp)))
      (:catch (err)
        (warp:log! :error "warp-service"
                   "Mesh resolution failed for '%s': %S"
                   service-name err)
        (loom:rejected! err)))))

(defun warp-service--consensus-select (endpoint-lists)
  "Private: Select endpoints using a consensus from multiple sources.

This function takes a list of endpoint lists (one from each successful
discovery source). It scores each endpoint based on how many sources
it appeared in and returns only those that meet a majority threshold.

Arguments:
- `endpoint-lists` (list): A list of lists of `warp-service-endpoint`s.

Returns:
- (loom-promise): A promise that resolves with a filtered list of
  `warp-service-endpoint`s that passed the consensus check, or rejects
  if no consensus is reached."
  (let ((endpoint-scores (make-hash-table :test 'equal))
        (all-endpoints (cl-mapcar #'car endpoint-lists)))

    (dolist (endpoints endpoint-lists)
      (dolist (endpoint endpoints)
        (let ((key (warp-service-endpoint-address endpoint)))
          (incf (gethash key endpoint-scores 0)))))

    (let* ((threshold (ceiling (/ (length endpoint-lists) 2.0)))
           (consensual-endpoints
            (cl-remove-if-not
             (lambda (ep)
               (>= (gethash (warp-service-endpoint-address ep)
                            endpoint-scores 0)
                   threshold))
             (car all-endpoints))))
      (if consensual-endpoints
          (loom:resolved! consensual-endpoints)
        (loom:rejected!
         (warp:error! :type 'warp-service-not-found
                      :message "No consensus reached on service endpoints."))))))

(defun warp:service-mesh-enabled-p ()
  "Public: Check if the service mesh integration is enabled.

Returns:
- (boolean): `t` if the service mesh is enabled, `nil` otherwise."
  (let ((config (warp:get-config :service-config)))
    (plist-get config :service-mesh-enabled-p)))

;;;---------------------------------------------------------------------------
;;; Individual Policy Definitions
;;;---------------------------------------------------------------------------

(warp:defpolicy :default-retry
  "A standard, defensive retry policy for transient network failures.
Applies 3 retries with an exponential backoff delay to give services
time to recover."
  :type :retry
  :retries 3
  :delay-strategy :exponential-backoff
  :delay-options '((:max-delay 5.0)))

(warp:defpolicy :aggressive-retry
  "An aggressive retry policy for critical operations that must succeed.
Applies 5 retries with a shorter delay."
  :type :retry
  :retries 5
  :delay-strategy :exponential-backoff
  :delay-options '((:max-delay 2.0)))

(warp:defpolicy :no-retry
  "A policy that explicitly disables automatic retries."
  :type :retry
  :retries 0)

(warp:defpolicy :short-timeout
  "A short timeout policy for fast, idempotent operations."
  :type :timeout
  :timeout 2.0)

(warp:defpolicy :long-timeout
  "A long timeout policy for potentially slow, long-running operations
like complex queries or deployments."
  :type :timeout
  :timeout 300.0)

(warp:defpolicy :round-robin-lb
  "The default load balancing policy, distributing requests sequentially."
  :type :load-balancer
  :strategy :round-robin)

(warp:defpolicy :least-connections-lb
  "A load balancing policy that favors the least-loaded worker, ideal
for routing to workers with varying capacities or workloads."
  :type :load-balancer
  :strategy :least-connections)

;;;---------------------------------------------------------------------------
;;; Policy Set Definitions
;;;---------------------------------------------------------------------------

(warp:defpolicy-set default-resilient-policy
  "The standard, balanced policy set for most client communication."
  :default-retry
  :short-timeout
  :round-robin-lb)

(warp:defpolicy-set high-availability-policy
  "A policy set optimized for critical services requiring high uptime.
It uses more aggressive retries to handle transient faults."
  :aggressive-retry
  :short-timeout
  :least-connections-lb)

(warp:defpolicy-set long-timeout-policy
  "A policy set for operations that are expected to take a long time,
such as deployments or batch jobs. It disables retries by default."
  :no-retry
  :long-timeout
  :round-robin-lb)

;;;---------------------------------------------------------------------------
;;; Service Plugin Definition
;;;---------------------------------------------------------------------------

(warp:defplugin :service-discovery
  "Provides the core service discovery and gateway infrastructure.
This plugin installs the service mesh infrastructure into the runtime.

It uses a profile-based approach to provide different capabilities:
- For a `:worker`, it provides the ability to host and announce services.
- For a `:cluster-worker`, it provides the centralized control plane
for service registration, discovery, and routing."
  :version "1.4.0"
  :dependencies '(warp-component warp-event warp-balancer warp-registry
                  warp-rpc warp-protocol warp-plugin warp-config
                  warp-state-manager warp-managed-worker
                  warp-dialer)
  :profiles
  `((:worker
     :doc "Enables the service loader, allowing a worker to host services."
     :components
     `((service-loader
        :doc "Dynamically discovers and initializes all defined services."
        :requires '(runtime-instance)
        :priority 90 ; Run late to ensure dependencies are ready.
        :start (lambda (_instance ctx runtime)
                 ;; When the component starts, it runs all the service
                 ;; initializer functions that were registered by
                 ;; `warp:defservice-implementation` macros at load time.
                 (warp:service-run-initializers runtime)))))

    (:cluster-worker
     :doc "Enables the full service discovery stack for a cluster leader."
     :components
     `(;; The dialer is now a core component of the service mesh. It
       ;; provides a high-level abstraction for connecting to services.
       (dialer-service
        :doc "The unified dialer service for the cluster."
        :requires '(config-service service-registry load-balancer)
        :factory (lambda (cfg-svc registry balancer)
                   (let* ((dialer (%%make-dialer-service
                                   :service-registry registry
                                   :load-balancer balancer))
                          ;; Read the pool settings from the central config.
                          (pool-config (warp:config-service-get
                                        cfg-svc :connection-pool))
                          (pool (warp:resource-pool-create
                                 :name (intern
                                        (format "%s-conn-pool"
                                                (warp-dialer-service-id dialer)))
                                 ;; Define how to create a new connection.
                                 :factory-fn (lambda (address)
                                               (warp-dialer--connection-factory
                                                dialer address))
                                 ;; Define how to destroy a connection.
                                 :destructor-fn #'warp-dialer--connection-destructor
                                 ;; Define how to check a connection's health.
                                 :health-check-fn #'warp-dialer--connection-health-check
                                 ;; Apply the loaded configuration.
                                 :idle-timeout (plist-get pool-config
                                                          :idle-timeout 300)
                                 :max-size (plist-get pool-config
                                                      :max-size 50)
                                 :min-size (plist-get pool-config
                                                      :min-size 1)
                                 :max-wait-time (plist-get pool-config
                                                           :max-wait-time 5.0))))
                     ;; Set the created pool back into the dialer struct.
                     (setf (warp-dialer-service-connection-pool dialer) pool)
                     dialer))
        :start (lambda (self ctx) (warp:dialer-start self))
        :stop (lambda (self ctx) (warp:dialer-shutdown self)))

       (load-balancer
        :doc "The routing brain of the service mesh. Selects the best
worker using a configurable, metrics-aware strategy."
        :requires '(config state-manager)
        :factory
        (lambda (cfg state-mgr)
          (warp:balancer-strategy-create
           ;; The specific balancing algorithm is read from config.
           :type (warp:config-service-get cfg :load-balance-strategy)
           ;; Filter out any unhealthy workers from selection.
           :health-check-fn
           #'(lambda (w) (eq (warp-managed-worker-health-status w) :healthy))
           ;; Provides the balancer the full list of potential worker targets.
           :get-all-workers-fn
           (lambda (&key pool-name)
             (let ((workers (hash-table-values
                             (warp:state-manager-get state-mgr '(:workers)))))
               (if pool-name
                   (cl-remove-if-not
                    #'(lambda (w) (string= (warp-managed-worker-pool-name w)
                                           pool-name))
                    workers)
                 workers)))
           ;; Calculates a 'load score', heavily penalizing degraded workers
           ;; to route traffic away from them.
           :connection-load-fn
           (lambda (m-worker)
             (let* ((metrics (warp-managed-worker-last-reported-metrics
                              m-worker))
                    (base-load (if metrics (gethash :active-request-count
                                                    metrics 0) 0)))
               (if (eq (warp-managed-worker-health-status m-worker) :degraded)
                   (+ base-load
                      (cluster-config-resource-degraded-load-penalty cfg))
                 base-load)))
           ;; Enables adaptive, weighted load balancing by calculating a
           ;; worker's 'effective weight' in real-time.
           :dynamic-effective-weight-fn
           (lambda (m-worker)
             (let* ((health (warp-managed-worker-health-status m-worker))
                    (weight (warp-managed-worker-initial-weight m-worker))
                    (metrics (warp-managed-worker-last-reported-metrics
                              m-worker))
                    (cpu (if metrics (gethash :cpu-utilization
                                              metrics 0.0) 0.0))
                    (reqs (if metrics (gethash :active-request-count
                                               metrics 0) 0)))
               (pcase health
                 (:unhealthy 0.0) ; A weight of 0 receives no traffic.
                 (:degraded (* weight 0.25)) ; Receives 25% of normal traffic.
                 ;; For healthy workers, apply penalties based on load.
                 (_ (let ((cpu-penalty (cond ((> cpu 80.0) 0.1)
                                              ((> cpu 50.0) 0.5)
                                              (t 1.0)))
                          (req-penalty (cond ((> reqs 50) 0.1)
                                             ((> reqs 20) 0.5)
                                             (t 1.0))))
                      (max 0.001 (* weight cpu-penalty req-penalty))))))))))
        :metadata `(:leader-only t))

       (service-registry
        :doc "The authoritative, reactive catalog for all cluster services."
        :requires '(cluster-orchestrator event-system rpc-system load-balancer)
        :factory (lambda (cluster es rpc lb)
                   (warp:service-registry-create
                    :id (warp-cluster-id cluster) :event-system es
                    :rpc-system rpc :load-balancer lb))
        :metadata `(:leader-only t))

       (service-gateway
        :doc "The central entry point for routing service requests."
        :requires '(cluster-orchestrator service-client rpc-system)
        :factory (lambda (cluster client rpc)
                   (warp:gateway-create
                    :name (format "%s-gateway" (warp-cluster-id cluster))
                    :service-client client :rpc-system rpc))
        :metadata `(:leader-only t)))
     )))

(provide 'warp-service)
;;; warp-service.el ends here